package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/coreos/go-oidc/v3/oidc"
	"golang.org/x/oauth2"
)

func TestExecApi(t *testing.T) {
	var mockOIDC *httptest.Server
	mockOIDC = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Printf("Request URL: %s", r.URL.String())
		w.Header().Set("Content-Type", "application/json")
		// Use actual server URL as issuer
		w.Write([]byte(fmt.Sprintf(`{
			"issuer": "%s",
			"authorization_endpoint": "%s/auth",
			"token_endpoint": "%s/token"
		}`, mockOIDC.URL, mockOIDC.URL, mockOIDC.URL)))
	}))
	defer mockOIDC.Close()

	// Create mock API server
	mockAPI := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Printf("Request URL: %s", r.URL.String())
		// Verify Bearer token
		authHeader := r.Header.Get("Authorization")
		if authHeader != "Bearer test-access-token" {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"message": "Hello from test API"}`))
	}))
	defer mockAPI.Close()

	// Test token
	testToken := Token{
		AccessToken:  "test-access-token",
		IdToken:      "test-id-token",
		RefreshToken: "test-refresh-token",
	}

	// Test context
	ctx := context.Background()

	// Execute execApi
	err := execApi(ctx, testToken, mockAPI.URL, mockOIDC.URL)
	if err != nil {
		t.Errorf("execApi failed: %v", err)
	}
}

func TestDebugApi(t *testing.T) {
	ctx := context.Background()
	baseUrl := testServerUrl
	providerUrl := providerUrl

	provider, err := oidc.NewProvider(ctx, providerUrl)
	if err != nil {
		t.Fatalf("failed to get provider: %v", err)
	}

	oauth2Config := oauth2.Config{
		ClientID:    "app",
		RedirectURL: "http://localhost:3000/callback",
		Endpoint:    provider.Endpoint(),
		Scopes:      []string{oidc.ScopeOpenID, "profile", "email"},
	}

	ts := oauth2Config.TokenSource(ctx, &oauth2.Token{
		// AccessToken: token.AccessToken,
		// TokenType:   "Bearer",
		RefreshToken: "test-refresh-token",
	})

	// Create HTTP client
	client := oauth2.NewClient(
		WithCustomTransport(ctx, ts),
		ts,
	)

	// Execute API request
	resp, err := client.Get(baseUrl + "/api/hello")
	if err != nil {
		t.Fatalf("failed to call API: %v", err)
	}
	defer resp.Body.Close()

	// Read response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		t.Fatalf("failed to read response: %v", err)
	}
	log.Println(string(body))
}

func WithCustomTransport(ctx context.Context, ts oauth2.TokenSource) context.Context {
	return context.WithValue(ctx, oauth2.HTTPClient, &http.Client{
		Transport: &CustomTransport{ts: ts},
	})
}

type CustomTransport struct {
	ts oauth2.TokenSource
}

// RoundTrip is a method of CustomTransport that implements the http.RoundTripper interface.
// This Transport is used to overwrite the Authorization header set within the RoundTrip of oauth2.Transport with a custom header.
// By setting this Transport in the ctx of oauth2.NewClient with the key oauth2.HTTPClient, this Transport will be set as the Base of oauth2.Transport.
// It is called at the end of the RoundTrip process of the default oauth2.Transport generated by oauth2.NewClient.
func (t *CustomTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	token, err := t.ts.Token()
	if err != nil {
		return nil, err
	}

	idToken := token.Extra("id_token")
	if idToken == nil {
		return nil, fmt.Errorf("id_token is not found")
	}

	// Overwrite the Authorization header set by oauth2.Transport.RoundTrip
	req.Header.Set("Authorization", "Custom "+idToken.(string))
	client := http.DefaultClient
	return client.Do(req)
}
